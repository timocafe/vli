/*
 *Very Large Integer Library, License - Version 1.0 - May 3rd, 2012
 *
 *Timothee Ewart - University of Geneva,
 *Andreas Hehn - Swiss Federal Institute of technology Zurich.
 *
 *Permission is hereby granted, free of charge, to any person or organization
 *obtaining a copy of the software and accompanying documentation covered by
 *this license (the "Software") to use, reproduce, display, distribute,
 *execute, and transmit the Software, and to prepare derivative works of the
 *Software, and to permit third-parties to whom the Software is furnished to
 *do so, all subject to the following:
 *
 *The copyright notices in the Software and this entire statement, including
 *the above license grant, this restriction and the following disclaimer,
 *must be included in all copies of the Software, in whole or in part, and
 *all derivative works of the Software, unless such copies or derivative
 *works are solely in the form of machine-executable object code generated by
 *a source language processor.
 *
 *THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 *SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 *FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 *ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *DEALINGS IN THE SOFTWARE.
 */

#ifndef VLI_TEST_HEADER_HPP
#define VLI_TEST_HEADER_HPP

#define BOOST_TEST_MODULE integer_cpu
#define BOOST_TEST_NO_MAIN
#include <boost/test/unit_test.hpp>
#include <boost/preprocessor/cat.hpp>
#include <stdexcept>
#include <vli/integer.hpp>
#include <iostream>
#ifdef VLI_FUZZ_TESTS
#include <boost/lexical_cast.hpp>
#include <boost/random/mersenne_twister.hpp>
#include <boost/random/uniform_int_distribution.hpp>
#endif // VLI_FUZZ_TESTS

#ifdef VLI_FUZZ_TESTS
#define VLI_FUZZABLE_TEST( TEST_NAME )                          \
    template <typename Initalizer>                              \
    static void BOOST_PP_CAT(TEST_NAME,_test(Initalizer init)); \
    BOOST_AUTO_TEST_CASE( TEST_NAME )                           \
    {                                                           \
        std::cout<<"Running "<<vli::test::fuzz_initializer::fuzz_iterations<<" iterations..."<<std::endl;    \
        for(unsigned int i=0; i < vli::test::fuzz_initializer::fuzz_iterations; ++i)                                  \
            BOOST_PP_CAT(TEST_NAME,_test(fuzz_initializer())); \
    }                                                           \
    template <typename Initalizer>                              \
    static void BOOST_PP_CAT(TEST_NAME,_test(Initalizer init))
#define VLI_STATIC_TEST( TEST_NAME )                            \
    template <typename Initalizer>                              \
    static void BOOST_PP_CAT(TEST_NAME,_test(Initalizer init))
#else  // VLI_FUZZ_TESTS
#define VLI_FUZZABLE_TEST( TEST_NAME ) VLI_STATIC_TEST( TEST_NAME )
#define VLI_STATIC_TEST( TEST_NAME )                            \
    template <typename Initalizer>                              \
    static void BOOST_PP_CAT(TEST_NAME,_test(Initalizer init)); \
    BOOST_AUTO_TEST_CASE( TEST_NAME )                           \
    {                                                           \
        BOOST_PP_CAT(TEST_NAME,_test(initializer()));           \
    }                                                           \
    template <typename Initalizer>                              \
    static void BOOST_PP_CAT(TEST_NAME,_test(Initalizer init))
#endif // VLI_FUZZ_TESTS

namespace vli {
namespace test {

typedef integer<VLI_SIZE> integer_type;
typedef integer<2*VLI_SIZE> integer_type_double;
typedef integer<2*VLI_SIZE>::value_type type;

enum variant_enum {
      max_positive = 0      // fill with the max positive number
    , overflow_safe = 1     // fill such that x+x doesn't cause an overflow
    , fill_ff = 2           // fill with 0xff..ff
    , multiplies_overflow_safe = 3
};

struct initializer {
    void operator()(integer_type& v, variant_enum variant = overflow_safe) {
            for(std::size_t i=0; i != integer_type::numwords; ++i)
                v[i] = std::numeric_limits<integer_type::value_type>::max();
        switch(variant) {
            case overflow_safe:
                v[integer_type::numwords-1] = 1;
                break;
            case max_positive:
                v[integer_type::numwords-1] = 0x7fffffffffffffff;
                break;
            case multiplies_overflow_safe:
                v[integer_type::numwords/2-1] = 0x7fffffffffffffff;
                for(std::size_t i=integer_type::numwords/2; i != integer_type::numwords; ++i)
                    v[i] = 0;
                break;
            case fill_ff:
                break;
            default:
                throw(std::runtime_error("init variant not implemented"));
        }
    }
    void operator()(integer_type_double& v, variant_enum variant = overflow_safe) {
        for(std::size_t i=0; i != integer_type_double::numwords; ++i)
            v[i] = std::numeric_limits<integer_type::value_type>::max();
        switch(variant) {
            case max_positive:
                v[integer_type_double::numwords-1] = v[integer_type_double::numwords-1] & ~(integer_type::value_type(1)<<(sizeof(integer_type_double::value_type)*8-1));
                break;
            case overflow_safe:
                v[integer_type_double::numwords-1] = 1;
                break;
            case multiplies_overflow_safe:
                v[integer_type_double::numwords/2-1] = v[integer_type_double::numwords/2-1] & 0x7fffffffffffffff;
                for(std::size_t i=integer_type_double::numwords/2; i != integer_type_double::numwords; ++i)
                    v[i] = 0;
                break;
            default:
                throw(std::runtime_error("init variant not implemented"));
       }
    }
    void operator()(int& i, variant_enum variant = overflow_safe) {
        switch(variant) {
            case overflow_safe:
                i = std::numeric_limits<int>::max()/2;
                break;
            case max_positive:
                i = std::numeric_limits<int>::max();
                break;
            case fill_ff:
                i = -1;
                break;
            default:
                throw(std::runtime_error("init variant not implemented"));
        }
    }
};
#ifdef VLI_FUZZ_TESTS
struct fuzz_initializer {
      static boost::random::mt19937                                           rng;
      static boost::random::uniform_int_distribution<integer_type::value_type>    integer_value_type_max_rnd;
      static boost::random::uniform_int_distribution<int>                     int_plus_rnd;
    static unsigned int                                                     fuzz_iterations;
    void operator()(integer_type& v, variant_enum variant = overflow_safe) {
        for(std::size_t i=0; i != integer_type::numwords; ++i)
            v[i] = integer_value_type_max_rnd(rng);
        switch(variant) {
            case max_positive:
                v[integer_type::numwords-1] = v[integer_type::numwords-1] & ~(integer_type::value_type(1)<<(sizeof(integer_type::value_type)*8-1));
                break;
            case overflow_safe:
                v[integer_type::numwords-1] = 1;
                break;
            case multiplies_overflow_safe:
                v[integer_type::numwords/2-1] = v[integer_type::numwords/2-1] & 0x7fffffffffffffff;
                for(std::size_t i=integer_type::numwords/2; i != integer_type::numwords; ++i)
                    v[i] = 0;
                break;
            default:
                throw(std::runtime_error("init variant not implemented"));
        }
    }
    void operator()(integer_type_double& v, variant_enum variant = overflow_safe) {
        for(std::size_t i=0; i != integer_type_double::numwords; ++i)
            v[i] = integer_value_type_max_rnd(rng);
        switch(variant) {
            case max_positive:
                v[integer_type_double::numwords-1] = v[integer_type_double::numwords-1] & ~(integer_type::value_type(1)<<(sizeof(integer_type_double::value_type)*8-1));
                break;
            case overflow_safe:
                v[integer_type_double::numwords-1] = 1;
                break;
            case multiplies_overflow_safe:
                v[integer_type_double::numwords/2-1] = v[integer_type_double::numwords/2-1] & 0x7fffffffffffffff;
                for(std::size_t i=integer_type_double::numwords/2; i != integer_type_double::numwords; ++i)
                    v[i] = 0;
                break;
            default:
                throw(std::runtime_error("init variant not implemented"));
        }
    }
    void operator()(int& i, variant_enum variant = overflow_safe) {
        i = int_plus_rnd(rng);
        switch(variant) {
            // TODO this will always give a positive number
            case overflow_safe:
                i/=2;
                break;
            default:
                throw(std::runtime_error("init variant not implemented"));
        }
    }
};
unsigned int                                                  fuzz_initializer::fuzz_iterations        = 0;
boost::random::mt19937                                        fuzz_initializer::rng;
boost::random::uniform_int_distribution<integer_type::value_type> fuzz_initializer::integer_value_type_max_rnd = boost::random::uniform_int_distribution<integer_type::value_type>(0,std::numeric_limits<integer_type::value_type>::max());
boost::random::uniform_int_distribution<int>                  fuzz_initializer::int_plus_rnd           = boost::random::uniform_int_distribution<int>(0,std::numeric_limits<int>::max());
#endif // VLI_FUZZ_TESTS


template <typename T>
struct extended {
};

template <std::size_t NumBits>
struct extended<integer<NumBits> > {
    typedef integer<NumBits+64> type;
};

template <typename T>
struct double_sized_integer {
};

template <std::size_t NumBits>
struct double_sized_integer<integer<NumBits> > {
    typedef integer<2*NumBits> type;
};

} // end namespace test
} // end namespace integer

int main(int argc, char* argv[])
{
#ifdef VLI_FUZZ_TESTS

    if(argc > 1 && argc <= 3) {
        vli::test::fuzz_initializer::fuzz_iterations = boost::lexical_cast<unsigned int>(argv[1]);
        unsigned int seed = std::time(0);
        if (argc == 3)
            seed = boost::lexical_cast<unsigned int>(argv[2]);
        std::cout<<"Using random seed: "<<seed<<std::endl;
        vli::test::fuzz_initializer::rng.seed(seed);

    } else {
        std::cerr<<"Usage:"<<std::endl;
        std::cerr<<argv[0]<<" <iterations> [<random seed>]"<<std::endl;
        return -1;
    }
#endif // VLI_FUZZ_TESTS
    return ::boost::unit_test::unit_test_main( &init_unit_test, argc, argv );
}

#endif // VLI_TEST_HEADER_HPP
