/*
*Very Large Integer Library, License - Version 1.0 - May 3rd, 2012
*
*Timothee Ewart - University of Geneva, 
*Andreas Hehn - Swiss Federal Institute of technology Zurich.
*
*Permission is hereby granted, free of charge, to any person or organization
*obtaining a copy of the software and accompanying documentation covered by
*this license (the "Software") to use, reproduce, display, distribute,
*execute, and transmit the Software, and to prepare derivative works of the
*Software, and to permit third-parties to whom the Software is furnished to
*do so, all subject to the following:
*
*The copyright notices in the Software and this entire statement, including
*the above license grant, this restriction and the following disclaimer,
*must be included in all copies of the Software, in whole or in part, and
*all derivative works of the Software, unless such copies or derivative
*works are solely in the form of machine-executable object code generated by
*a source language processor.
*
*THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
*SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
*FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
*ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
*DEALINGS IN THE SOFTWARE.
*/

#ifndef VLI_VLI_IPP
#define VLI_VLI_IPP

namespace vli {
    /* \cond I do not need this part in the doc*/
namespace detail {

#if defined __GNU_MP_VERSION
    template <typename GMPClass>
    struct gmp_convert_helper {
        template <std::size_t NumBits>
        static GMPClass apply(integer<NumBits> a) {
            // integer::value_type = uint64_t is an unsigned long long on some machines.
            // GMP doesn't work with unsigned long longs, but only with unsigned long int.
            // Hence we will cast to unsigned long int manually,
            // given that sizeof(unsigned long long) == sizeof(unsigned long int).
            BOOST_STATIC_ASSERT(sizeof(typename integer<NumBits>::value_type) == sizeof(unsigned long int));
            bool const neg = a.is_negative();
            if(neg)
                negate_inplace(a);
            GMPClass result(0);
            GMPClass factor(1);

            GMPClass const segment_factor( mpz_class(~static_cast<unsigned long int>(0)) + 1 );

            for(typename integer<NumBits>::size_type i=0; i< integer<NumBits>::numwords; ++i) {
                result += factor * static_cast<unsigned long int>(a[i]);
                factor *= segment_factor;
            }
            if(neg)
                result *= -1;
            return result;
        }
    };
#endif //__GNU_MP_VERSION
} // end namespace detail

template <std::size_t NumBits>
integer<NumBits>::integer(){
    std::fill(begin(),end(),0);
}

template <std::size_t NumBits>
integer<NumBits>::integer(long int num) {
    // We rely on the implementation-defined >>= operator for negative long ints
    // to fill the most significant part with 1 (only for negative values)
    assert( -1l >> 1 == -1l );
    data_[0] = num;
    value_type a = num >> std::numeric_limits<long int>::digits;
    std::fill(begin()+1,end(),a);
}

#if defined __GNU_MP_VERSION
template <std::size_t NumBits>
integer<NumBits>::operator mpz_class() const{
    return detail::gmp_convert_helper<mpz_class>::apply(*this);
}

template <std::size_t NumBits>
integer<NumBits>::operator mpq_class() const{
    return detail::gmp_convert_helper<mpq_class>::apply(*this);
}
#endif //__GNU_MP_VERSION

template <std::size_t NumBits>
typename integer<NumBits>::reference integer<NumBits>::operator[](size_type i){
    assert( i < numwords );
    return *(data_+i);
}

template <std::size_t NumBits>
typename integer<NumBits>::const_reference integer<NumBits>::operator[](size_type i) const{
    assert( i < numwords );
    return *(data_+i);
}

template <std::size_t NumBits>
integer<NumBits> integer<NumBits>::operator-() const{
    integer tmp(*this);
    tmp.negate();
    return tmp;
}

template <std::size_t NumBits>
bool integer<NumBits>::operator == (integer const& integer_a) const{
    return std::equal(begin(),end(),integer_a.begin());
}

template <std::size_t NumBits>
bool integer<NumBits>::operator != (integer const& integer_a) const{
    return !(*this == integer_a);
}

template <std::size_t NumBits>
bool integer<NumBits>::operator < (integer const& integer_a) const{
    integer tmp(*this);
    return ( (tmp -= integer_a).is_negative() );
}

template <std::size_t NumBits>
bool integer<NumBits>::operator <= (integer const& integer_a) const{
    integer tmp(*this);
    return ( (tmp -= integer_a).is_negative() | (*this == integer_a) );
}

template <std::size_t NumBits>
bool integer<NumBits>::operator > (integer const& integer_a) const{
    return ( integer_a < *this );
}

template <std::size_t NumBits>
bool integer<NumBits>::operator >= (integer const& integer_a) const{
    return ( integer_a <= *this );
}

template <std::size_t NumBits>
bool integer<NumBits>::operator < (long int i) const{
    integer tmp(i);
    return (tmp > *this);
}

template <std::size_t NumBits>
bool integer<NumBits>::operator > (long int i) const{
    integer tmp(i);
    return ( (tmp-=*this).is_negative() );
}

template <std::size_t NumBits>
bool integer<NumBits>::is_zero() const{
    bool result = (data_[0] == 0);
    for(std::size_t i=1; i < numwords; ++i)
        result &= (data_[i] == 0);
    return result;
}

// c - negative number
template <std::size_t NumBits>
void integer<NumBits>::negate(){
    std::transform(begin(),end(),begin(),[](value_type v){return ~v;}); // std::bit_not c++14
    (*this)+=1;
}

template <std::size_t NumBits>
bool integer<NumBits>::is_negative() const{
    return static_cast<bool>( data_[numwords-1] >> (std::numeric_limits<value_type>::digits-1) );
}

// c - basic operators
template <std::size_t NumBits>
integer<NumBits>& integer<NumBits>::operator = (long int const num){
    assert( -1l >> 1 == -1l );
    data_[0] = num;
    value_type a = num >> std::numeric_limits<long int>::digits;
    std::fill(begin()+1,end(),a);
    return *this;
}

template <std::size_t NumBits>
integer<NumBits>& integer<NumBits>::operator >>= (long int const a){
    assert( a >= 0 );
    assert( a < 64 );
    for(size_type i = 0; i < numwords-1; ++i){
        data_[i] >>= a;
        data_[i] |= (data_[i+1] << (std::numeric_limits<value_type>::digits-a));
    }
    // We do an arithmentic shift, i.e. fill the left-most (most significant) part
    // with 0 for positive and 1 for negative values
    //
    // We rely on the implementation-defined >>= operator for negative long ints
    // to fill the most significant part with 1 (only for negative values)
    assert( -1l >> 1 == -1l );
    reinterpret_cast<boost::int64_t&>(data_[numwords-1]) >>= a;
    return *this;
}

template <std::size_t NumBits>
integer<NumBits>& integer<NumBits>::operator <<= (long int const a){
    assert( a >= 0 );
    assert(a < 64);
    for(size_type i = numwords-1; i > 0; --i){
        data_[i] <<= a;
        data_[i] |= (data_[i-1] >> (std::numeric_limits<value_type>::digits-a));
    }
    data_[0] <<= a;
    return *this;
}

template <std::size_t NumBits>
integer<NumBits>& integer<NumBits>::operator |= (integer const& integer_a){
    std::transform(begin(),end(),integer_a.begin(),begin(),std::bit_or<value_type>());
    return *this;
}

template <std::size_t NumBits>
integer<NumBits>& integer<NumBits>::operator ^= (integer const& integer_a){
    std::transform(begin(),end(),integer_a.begin(),begin(),std::bit_xor<value_type>());
    return *this;
}

template <std::size_t NumBits>
integer<NumBits>& integer<NumBits>::operator &= (integer const& integer_a){
    std::transform(begin(),end(),integer_a.begin(),begin(),std::bit_and<value_type>());
    return *this;
}

// integer_a %/= integer_b
template <std::size_t NumBits>
void quotient_helper(integer<NumBits> const& integer_b, integer<NumBits>& integer_quotient, integer<NumBits>& integer_rest){
    integer<NumBits> tmp(integer_b);
    integer<NumBits> tmp_quotient(1);

    if(integer_rest >= tmp){
        while(integer_rest >= tmp){
            tmp <<= 1;
            tmp_quotient <<=1;
        }

        tmp >>= 1;
        tmp_quotient >>= 1;
        integer_quotient |= tmp_quotient;

        integer_rest -= tmp;
    }else{
        return;
    }
    quotient_helper(integer_b, integer_quotient, integer_rest);
}


// Saint HPC forgives me
template <std::size_t NumBits>
integer<NumBits>& integer<NumBits>::operator %= (integer<NumBits> integer_a){
    if(integer_a.is_zero())
        throw integer_division_by_zero_error();

    bool const sign_this  = this->is_negative();
    bool const sign_integer_a = integer_a.is_negative();

    if(sign_this)
        this->negate();

    if(sign_integer_a)
        integer_a.negate();

    integer<NumBits> tmp(integer_a);

    while(*this >= tmp)
        tmp <<= 1;

    while(*this >= integer_a){
        tmp >>= 1;
        if(tmp <= *this)
            *this -= tmp;
    }

    if(sign_this^sign_integer_a) {
        this->negate();
        /* say gmp convention is correct
        if(sign_this)
            (*this) = integer_a - (*this);*/
    }

    return *this;
}

// Saint HPC forgives me
template <std::size_t NumBits>
integer<NumBits>& integer<NumBits>::operator /= (integer<NumBits> integer_a){
    if(integer_a.is_zero())
        throw integer_division_by_zero_error();

    bool const sign_this  = this->is_negative();
    bool const sign_integer_a = integer_a.is_negative();

    if(sign_this)
        this->negate();

    if(sign_integer_a)
        integer_a.negate();

    integer<NumBits> integer_rest(*this);
    *this ^= *this; //flush to 0
    quotient_helper(integer_a, *this, integer_rest);

    if(sign_this^sign_integer_a)
        this->negate();
    /* say gmp convention is correct
      if(sign_this){
      (*this).negate();
      (*this)-=1;
    }
    if(sign_integer_a)
      (*this).negate();
    }*/
    return *this;
}

template <std::size_t NumBits>
integer<NumBits>& integer<NumBits>::operator += (integer<NumBits> const& integer_a){
    plus_assign(*this,integer_a);
    return *this;
}

template <std::size_t NumBits>
integer<NumBits>& integer<NumBits>::operator += (long int const a){
    plus_assign(*this,a);
    return *this;
}

template <std::size_t NumBits>
integer<NumBits>& integer<NumBits>::operator -= (integer<NumBits> const& integer_a){
    minus_assign(*this,integer_a);
    return *this;
}

template <std::size_t NumBits>
integer<NumBits>& integer<NumBits>::operator -= (long int const a){
    minus_assign(*this,a);
    return *this;
}

template <std::size_t NumBits>
integer<NumBits>& integer<NumBits>::operator *= (long int const a){
    multiplies_assign(*this,a);
    return *this;
}

template <std::size_t NumBits>
integer<NumBits>& integer<NumBits>::operator *= (integer<NumBits> const& integer_a){
    multiplies_assign(*this,integer_a);
    return *this;
}

template <std::size_t NumBits>
void integer<NumBits>::print_raw(std::ostream& os) const{
    os << "(" ;
    for(size_type i = numwords-1; i > 0; --i)
        os << data_[i]<<" ";
    os << data_[0];
    os << ")";
}

template <std::size_t NumBits>
void integer<NumBits>::print(std::ostream& os) const{
    os << get_str();
}

/**
 * Returns a string with a base10 represenation of the VLI
 */
template <std::size_t NumBits>
std::string integer<NumBits>::get_str() const {
    integer<NumBits> tmp;

    if((*this).is_negative()){
        const_cast<integer<NumBits> & >(*this).negate();

        for(size_type i=0; i<numwords; ++i)
            tmp[i] = (*this)[i];

        tmp.negate();
        const_cast<integer<NumBits> & >(*this).negate();
    }else{
        for(size_type i=0; i<numwords; ++i)
            tmp[i] = (*this)[i];
    }

    if(tmp.is_negative()){
        tmp.negate();
        size_type ten_exp = order_of_magnitude_base10(tmp);
        return std::string("-")+get_str_helper_inplace(tmp,ten_exp);
    }else{
        size_type ten_exp = order_of_magnitude_base10(tmp);
        return get_str_helper_inplace(tmp,ten_exp);
    }
}

/**
 * Returns the order of magnitude of 'value' in base10
 */
template <std::size_t NumBits>
typename integer<NumBits>::size_type integer<NumBits>::order_of_magnitude_base10(integer<NumBits> const& value) const {
    assert(!value.is_negative());

    integer<NumBits> value_cpy(value);
    integer<NumBits> decimal(1);
    size_type exp = 0;

    // Find correct order (10^exp) 
    while(!value_cpy.is_negative()){
        value_cpy=value; // reset
        integer<NumBits> previous_decimal(decimal);
        decimal *= 10;
        ++exp;
        if(decimal < previous_decimal) // Overflow! (we can handle it.)
        {
            break;
        }
        value_cpy-=decimal;
    }
    --exp;
    return exp;
}

/**
 * A helper function to generate the base10 representation for get_str().
 */
template <std::size_t NumBits>
std::string integer<NumBits>::get_str_helper_inplace(integer<NumBits>& value, size_type ten_exp) const {
    assert(!value.is_negative());

    // Create a number 10^(exponent-1) sin
    integer<NumBits> dec(1);
    for(size_type e=0; e < ten_exp; ++e)
        dec *= 10;

    // Find the right digit for 10^ten_exp
    integer<NumBits> value_cpy(value);
    int digit=0;
    while((!value_cpy.is_negative()) && digit<=11){
        value_cpy = value; // reset
        ++digit;
        if(digit*dec < (digit-1)*dec){ // Overflow (we can handle it.)
            break;
        }
        value_cpy-= digit*dec;
    }
    --digit; // we went to far

    assert(digit >=0);
    assert(digit < 10);

    value-= digit*dec;

    if(ten_exp <= 0)
        return std::to_string(digit);
    else
        return std::to_string(digit)+get_str_helper_inplace(value,ten_exp-1);
}

// free function algebra 
template <std::size_t NumBits>
void multiply_extend(integer<2*NumBits>& integer_res, integer<NumBits> const&  integer_a, integer<NumBits> const& integer_b) {
    multiplies<NumBits>(integer_res, integer_a, integer_b);
}

template <std::size_t NumBits>
void multiply_add(integer<2*NumBits>& integer_res, integer<NumBits> const&  integer_a, integer<NumBits> const& integer_b) {
    multiply_add_assign<NumBits>(integer_res, integer_a, integer_b);
}

template <std::size_t NumBits>
bool is_zero(integer<NumBits> const& v) {
    return v.is_zero();
}

template <std::size_t NumBits>
void negate_inplace(integer<NumBits>& v) {
    v.negate();
}

template <std::size_t NumBits>
const integer<NumBits+64> plus_extend (integer<NumBits> const &integer_a, integer<NumBits> const& integer_b){
      integer<NumBits+64> integer_res;
      plus_extend_assign<NumBits>(integer_res,integer_a,integer_b);
      return integer_res;
}

template <std::size_t NumBits>
const integer<NumBits> operator + (integer<NumBits> integer_a, long int b){
    integer_a += b;
    return integer_a;
}

template <std::size_t NumBits>
const integer<NumBits> operator + (long int b, integer<NumBits> const& integer_a){
    return integer_a+b;
}

template <std::size_t NumBits>
const integer<NumBits> operator - (integer<NumBits> integer_a, long int b){
    integer_a -= b;
    return integer_a;
}

template <std::size_t NumBits>
const integer<NumBits> operator * (integer<NumBits> integer_a, long int b){
    integer_a *= b;
    return integer_a;
}

template <std::size_t NumBits>
const integer<NumBits> operator * (long int b, integer<NumBits> const& a){
    return a*b;
}

template <std::size_t NumBits>
const integer<NumBits> operator + (integer<NumBits> const& integer_a, integer<NumBits> const& integer_b){
    integer<NumBits> tmp(integer_a);
    tmp += integer_b;
    return tmp;
}

template <std::size_t NumBits>
const integer<NumBits> operator - (integer<NumBits> const& integer_a, integer<NumBits> const& integer_b){
    integer<NumBits> tmp(integer_a);
    tmp -= integer_b;
    return tmp;
}

template <std::size_t NumBits>
const integer<NumBits> operator * (integer<NumBits> const& integer_a, integer<NumBits> const& integer_b){
    integer<NumBits> tmp(integer_a);
    tmp *= integer_b;
    return tmp;
}

template <std::size_t NumBits>
const integer<NumBits> operator / (integer<NumBits> const& integer_a, integer<NumBits> const& integer_b){
    integer<NumBits> tmp(integer_a);
    tmp /= integer_b;
    return tmp;
}


template <std::size_t NumBits>
const integer<NumBits> operator ^ (integer<NumBits> const& integer_a, integer<NumBits> const& integer_b){
    integer<NumBits> tmp(integer_a);
    tmp ^= integer_b;
    return tmp;
}

template <std::size_t NumBits>
const integer<NumBits> operator & (integer<NumBits> const& integer_a, integer<NumBits> const& integer_b){
    integer<NumBits> tmp(integer_a);
    tmp &= integer_b;
    return tmp;
}

template <std::size_t NumBits>
const integer<NumBits> operator | (integer<NumBits> const& integer_a, integer<NumBits> const& integer_b){
    integer<NumBits> tmp(integer_a);
    tmp |= integer_b;
    return tmp;
}

template <std::size_t NumBits>
const integer<NumBits> operator % (integer<NumBits> const& integer_a, integer<NumBits> const& integer_b){
    integer<NumBits> tmp(integer_a);
    tmp %= integer_b;
    return tmp;
}

//stream
template <std::size_t NumBits>
std::ostream& operator<< (std::ostream& os,  integer<NumBits> const& integer){
    if(os.flags() & std::ios_base::hex)
        integer.print_raw(os);
    else
        integer.print(os);
    return os;
}

    /* \cond I do not need this part in the doc*/

} // end namespace vli

#endif //VLI_VLI_IPP
