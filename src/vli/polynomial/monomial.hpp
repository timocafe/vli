/*
*Very Large Integer Library, License - Version 1.0 - May 3rd, 2012
*
*Andreas Hehn - Swiss Federal Institute of technology Zurich.
*Timothee Ewart - University of Geneva, 
*
*Permission is hereby granted, free of charge, to any person or organization
*obtaining a copy of the software and accompanying documentation covered by
*this license (the "Software") to use, reproduce, display, distribute,
*execute, and transmit the Software, and to prepare derivative works of the
*Software, and to permit third-parties to whom the Software is furnished to
*do so, all subject to the following:
*
*The copyright notices in the Software and this entire statement, including
*the above license grant, this restriction and the following disclaimer,
*must be included in all copies of the Software, in whole or in part, and
*all derivative works of the Software, unless such copies or derivative
*works are solely in the form of machine-executable object code generated by
*a source language processor.
*
*THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
*SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
*FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
*ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
*DEALINGS IN THE SOFTWARE.
*/

#ifndef VLI_MONOMIAL_HPP
#define VLI_MONOMIAL_HPP

#include <ostream>
#include <vli/polynomial/variable.hpp>
#include <vli/polynomial/detail/storage.hpp>

namespace vli {
/*! \class monomial
        \brief This class models a monomial 
*/
template <class Coeff, class Var0, class Var1 = no_variable, class Var2 = no_variable, class Var3 = no_variable>
struct monomial : public detail::element_descriptor_impl<Var0,Var1,Var2,Var3> {
    
    /*! \brief value type of the coefficient of the monomial */
    typedef Coeff           value_type;
    /*! \brief value type of the exponent of the monomial */
    typedef unsigned int    exponent_type;
     /* \cond I do not need this part in the doc*/
    typedef detail::element_descriptor_impl<Var0,Var1,Var2,Var3> base_type;
     /* \endcond */
    /**
     \brief Default constructor, the coefficient of the monomial is set up to 0
     */
    monomial()
    : detail::element_descriptor_impl<Var0,Var1,Var2,Var3>(0,0,0,0), c_(Coeff(1)) {
    }

    /**
     \brief explicit constructor, it necessitates at least one value
      \param exp0 value of the first exponent
      \param exp1 value of the second exponent (default 0)
      \param exp2 value of the third exponent (default 0)
      \param exp3 value of the fourth exponent (default 0)
     */
    explicit monomial(exponent_type exp0, exponent_type exp1 = 0, exponent_type exp2 = 0, exponent_type exp3 = 0)
    : detail::element_descriptor_impl<Var0,Var1,Var2,Var3>(exp0,exp1,exp2,exp3), c_(Coeff(1)) {
    }

    /**
     \fn operator - () const
     \brief negate a monomial
     */
    monomial operator - () const {
        monomial r(*this);
        r.c_ = -c_;
        return r;
    }

    /**
     \fn monomial& operator *= (T const& c)
     \brief multiply monomial by vli::integer or a long int
     \param c template parameter (vli::integer or a long int)
     */
    template <class T>
    monomial& operator *= (T const& c) {
        c_ *= c;
        return *this;
    }
    
    /* \cond I do not need this part in the doc*/
    void print(std::ostream& os) const {
        if(c_ > 0)
            os << "+";
        os << c_ << "*";
        os << static_cast<base_type>(*this);
    }
     /* \endcond */
    
    /**
     \fn bool operator == (monomial const& m) const
     \brief check if two monomials are equals
     \param m a monomial
     This operator checks if the exponent and the coefficients of the monomails are equals.
     */
    bool operator == (monomial const& m) const{
        return (
               (exponent(*this,Var0()) == exponent(m,Var0()))
            && (exponent(*this,Var1()) == exponent(m,Var1()))
            && (exponent(*this,Var2()) == exponent(m,Var2()))
            && (exponent(*this,Var3()) == exponent(m,Var3()))
            && (c_ == m.c_)
        );
    }
    
    /**
     \brief container of the monomial (vli::integer, gmp number, int ...)
     */
    Coeff c_;
};

/**
\brief Stream operator
\param os std::ostream
\param m a monomial
   As classical iostream operator
*/
template <class Coeff, class Var0, class Var1, class Var2, class Var3>
std::ostream& operator << (std::ostream& os, monomial<Coeff,Var0,Var1,Var2,Var3> const& m){
    m.print(os);
    return os;
}

/**
\brief multiplication between a monomial and vli::integer or a long int
\param m a monomial
\param c template parameter can be a vli::integer or a long int
This operator performs  a multiplication between the coefficients of two monomial, or a monomial and a long int
*/
template <class Coeff, class Var0, class Var1, class Var2, class Var3, class T>
monomial<Coeff,Var0,Var1,Var2,Var3> operator * (monomial<Coeff,Var0,Var1,Var2,Var3> m, T const& c) {
    m*=c;
    return m;
}
    
/**
\brief multiplication between a monomial and vli::integer or a long int
\param c template parameter can be a vli::integer or a long int
\param m a monomial
This operator performs  a multiplication between the coefficients of two monomial, or a monomial and a long int
*/
template <class Coeff, class Var0, class Var1, class Var2, class Var3, class T>
monomial<Coeff,Var0,Var1,Var2,Var3> operator * (T const& c, monomial<Coeff,Var0,Var1,Var2,Var3> const& m) {
    return m*c;
}

} //end namespace vli


#endif //VLI_MONOMIAL_HPP
